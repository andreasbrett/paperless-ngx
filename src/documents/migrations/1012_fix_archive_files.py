# Generated by Django 3.1.6 on 2021-02-07 22:26
import logging
import os
import shutil

from django.db import migrations
from django.db import models

from documents.migrations.manual.fix_archive_files import archive_name_from_filename
from documents.migrations.manual.fix_archive_files import archive_path_new
from documents.migrations.manual.fix_archive_files import archive_path_old
from documents.migrations.manual.fix_archive_files import create_archive_version

logger = logging.getLogger("paperless.migrations")

###############################################################################
# This code performs bidirection archive file transformation.
###############################################################################


def move_old_to_new_locations(apps, schema_editor):
    Document = apps.get_model("documents", "Document")

    affected_document_ids = set()

    old_archive_path_to_id = {}

    # check for documents that have incorrect archive versions
    for doc in Document.objects.filter(archive_checksum__isnull=False):
        old_path = archive_path_old(doc)

        if old_path in old_archive_path_to_id:
            affected_document_ids.add(doc.id)
            affected_document_ids.add(old_archive_path_to_id[old_path])
        else:
            old_archive_path_to_id[old_path] = doc.id

    # check that archive files of all unaffected documents are in place
    for doc in Document.objects.filter(archive_checksum__isnull=False):
        old_path = archive_path_old(doc)
        if doc.id not in affected_document_ids and not os.path.isfile(old_path):
            raise ValueError(
                f"Archived document ID:{doc.id} does not exist at: {old_path}",
            )

    # check that we can regenerate affected archive versions
    for doc_id in affected_document_ids:
        from documents.parsers import get_parser_class_for_mime_type

        doc = Document.objects.get(id=doc_id)
        parser_class = get_parser_class_for_mime_type(doc.mime_type)
        if not parser_class:
            raise ValueError(
                f"Document ID:{doc.id} has an invalid archived document, "
                f"but no parsers are available. Cannot migrate.",
            )

    for doc in Document.objects.filter(archive_checksum__isnull=False):
        if doc.id in affected_document_ids:
            old_path = archive_path_old(doc)
            # remove affected archive versions
            if os.path.isfile(old_path):
                logger.debug(f"Removing {old_path}")
                os.unlink(old_path)
        else:
            # Set archive path for unaffected files
            doc.archive_filename = archive_name_from_filename(doc.filename)
            Document.objects.filter(id=doc.id).update(
                archive_filename=doc.archive_filename,
            )

    # regenerate archive documents
    for doc_id in affected_document_ids:
        doc = Document.objects.get(id=doc_id)
        create_archive_version(doc)


def move_new_to_old_locations(apps, schema_editor):
    Document = apps.get_model("documents", "Document")

    old_archive_paths = set()

    for doc in Document.objects.filter(archive_checksum__isnull=False):
        new_archive_path = archive_path_new(doc)
        old_archive_path = archive_path_old(doc)
        if old_archive_path in old_archive_paths:
            raise ValueError(
                f"Cannot migrate: Archive file name {old_archive_path} of "
                f"document {doc.filename} would clash with another archive "
                f"filename.",
            )
        old_archive_paths.add(old_archive_path)
        if new_archive_path != old_archive_path and os.path.isfile(old_archive_path):
            raise ValueError(
                f"Cannot migrate: Cannot move {new_archive_path} to "
                f"{old_archive_path}: file already exists.",
            )

    for doc in Document.objects.filter(archive_checksum__isnull=False):
        new_archive_path = archive_path_new(doc)
        old_archive_path = archive_path_old(doc)
        if new_archive_path != old_archive_path:
            logger.debug(f"Moving {new_archive_path} to {old_archive_path}")
            shutil.move(new_archive_path, old_archive_path)


class Migration(migrations.Migration):
    dependencies = [
        ("documents", "1011_auto_20210101_2340"),
    ]

    operations = [
        migrations.AddField(
            model_name="document",
            name="archive_filename",
            field=models.FilePathField(
                default=None,
                editable=False,
                help_text="Current archive filename in storage",
                max_length=1024,
                null=True,
                unique=True,
                verbose_name="archive filename",
            ),
        ),
        migrations.AlterField(
            model_name="document",
            name="filename",
            field=models.FilePathField(
                default=None,
                editable=False,
                help_text="Current filename in storage",
                max_length=1024,
                null=True,
                unique=True,
                verbose_name="filename",
            ),
        ),
        migrations.RunPython(move_old_to_new_locations, move_new_to_old_locations),
    ]
